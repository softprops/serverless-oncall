import { EscalationPolicy, Services, PagerDutyClient, Service } from './@types/pagerduty';
import { Provider, CommandDescription, ServerlessInstance, ServerlessOptions } from './@types/serverless';
import * as PagerDuty from 'node-pagerduty';

const API_KEY_MISSING: string =
  "The serverless-oncall plugin requires a custom oncall configuration block containing an `oncall.apiKey` identifier\n\n" +
  '  ```\n' +
  '  custom:\n'+
  '      oncall:\n'+
  '         apiKey: "your-api-key-here"\n'+
  '         ^^^^^^\n'+
  '  ```\n\n' +
  "You can obtain one by visiting https://{your-company}.pagerduty.com/api_keys or talk to your friendly pagerduty admin";

const ESCALTION_POLICY_MISSING: string =
  'The serverless-oncall plugin requires a custom oncall configuration block containing an `oncall.escalationPolicy` identifier\n\n' +
  '  ```\n' +
  '  custom:\n'+
  '      oncall:\n'+
  '         escalationPolicy: "your-esclation-policy-identifier-here"\n'+
  '         ^^^^^^^^^^^^^^^^\n'+
  '  ```\n';

export = class Oncall {

    readonly serverless: ServerlessInstance;
    readonly options: ServerlessOptions;
    readonly commands: { [key: string]: CommandDescription };
    readonly hooks: { [key: string]: any };
    readonly provider: Provider;

    constructor(serverless: ServerlessInstance, options: ServerlessOptions) {
        this.serverless = serverless;
        this.options = options;
        this.provider = this.serverless.getProvider(this.serverless.service.provider.name);
        this.commands = {
            oncall: {
                usage: "Manages service oncall resources and incident management",
                commands: {
                    sync: {
                        usage: "Syncs serverless.yml oncall resource information with a remote provider",
                        lifecycleEvents: ["sync"]
                    },
                    escalationPolcies: {
                        usage: "List available ecalation policies provided by a remote provider",
                        lifecycleEvents: ["escalationPolcies"],
                        options: {
                            team: {
                                usage: 'limit policies to those of a given team',
                                shortcut: 't'
                            }
                        }
                    }
                }
            }
        };
        this.hooks = {
            'oncall:sync:sync': this.sync.bind(this),
            'oncall:escalationPolcies:escalationPolcies': this.escalationPolicies.bind(this),
            'before:info:info': this.info.bind(this)
        };
    }

    async findSevice(client: PagerDutyClient, serviceName: string): Promise<Service | undefined> {
        const args: { [key: string]: string } = { query: serviceName, 'include[]': 'integrations' };
        // this list should be sufficiently filtered that pagination is not needed
        let res = await client.services.listServices(args);
        const s: Services = JSON.parse(res.body);
        return s.services.find(s => s.name === serviceName);
    }

    async createService(client: PagerDutyClient, serviceName: string, escalationPolicy: string): Promise<Service | undefined> {
        const payload = {
            service: {
                type: "service",
                name: serviceName,
                description: "Managed by serverless oncall",
                escalation_policy: {
                    id: escalationPolicy,
                    type: 'escalation_policy_reference'
                },
                alert_creation: 'create_alerts_and_incidents'
            }
        };
        return client.services.createService(payload).then(res => {
            return res.body.service;
        });
    }

    // helper method to create a new custom event transform integration from the pagerduty api
    async createIntegration(client: PagerDutyClient, serviceName: string, serviceId: string): Promise<any> {
        this.serverless.cli.log('Creating oncall integration...');
        // https://www.pagerduty.com/blog/new-api-endpoints-increase-platform-extensibility/
        // docs https://v2.developer.pagerduty.com/v2/page/api-reference#!/Services/post_services_id_integrations
        // see https://v2.developer.pagerduty.com/v2/docs/creating-an-integration-inline for code api
        // see https://gist.github.com/richadams/3f51b617dc4051563fe358d7b0d40fe2 for a code example
        return client.services.createIntegration(serviceId, {
            integration: {
                config: {
                    fields: {
                        code: {
                            type: 'code',
                            value: "PD.emitGenericEvents([])// test"
                        }
                    }
                },
                name: `${serviceName} Event Transformer`,
                summary: `Event Transformer for ${serviceName} events generated by serverless-oncall`,
                type: "event_transformer_api_inbound_integration",
                vendor: {
                    id: "PCJ0EFQ",
                    type: "vendor_reference"
                }
            }
        });
    }

    // helper method to fetch escalation policies from the pager duty api
    async listEscalationPolcies(client: PagerDutyClient, options: any): Promise<EscalationPolicy[]> {
        const args: { [key: string]: string } = { 'include[]': 'teams' };
        if (options.team !== undefined) {
            args['team_ids[]'] = options.team;
        }
        if (options.offset !== undefined) {
            args.offset = options.offset;
        }
        return client.escalationPolicies.listEscalationPolicies(args).then(res => {
            // todo handle error response
            const response: { escalation_policies: EscalationPolicy[], limit: number, offset: number, more: boolean } = JSON.parse(res.body);
            if (response.more) {
                return this.listEscalationPolcies(
                    client,
                    Object.assign(
                        options,
                        {
                            offset: response.offset + response.limit
                        }
                    )
                ).then(next =>
                    response.escalation_policies.concat(next)
                );
            } else {
                return response.escalation_policies;
            }
        });
    }

    async escalationPolicies() {
        const oncall = this.config();
        const apiKey = oncall.apiKey;
        if (!apiKey) {
            throw new Error(API_KEY_MISSING);
        }
        this.serverless.cli.log(`resolving oncall escalationPolicies`);
        return await this.listEscalationPolcies(new PagerDuty(apiKey), this.options).then(policies => {
            policies.forEach(p => {
                this.serverless.cli.log(`${p.summary} (${p.id})`);
                if (p.teams.length > 0) {
                    this.serverless.cli.log(` * managed by ${p.teams.map(t => `${t.name} (${t.id})`)}`);
                } else {
                    this.serverless.cli.log(` * managed by an individual`);
                }
            });
        });
    }


    config() {
        const custom = this.serverless.service.custom || {};
        return custom.oncall || {};
    }

    async sync() {
        const config = this.config();
        const serviceName = `${this.serverless.service.service}-${this.provider.getStage()}`;
        this.serverless.cli.log(`Syncing oncall for service ${serviceName}...`);

        const apiKey = config.apiKey;
        if (!apiKey) {
            throw new Error(API_KEY_MISSING);
        }
        const escalationPolicy = config.escalationPolicy;
        if (!escalationPolicy) {
            throw new Error(ESCALTION_POLICY_MISSING);
        }
        const pd: PagerDutyClient = new PagerDuty(apiKey);
        let service = await this.findSevice(pd, serviceName);
        if (service === undefined) {
            this.serverless.cli.log(`Creating oncall service named ${serviceName}`);
            service = await this.createService(pd, serviceName, escalationPolicy);
            if (service !== undefined) {
                await this.createIntegration(pd, serviceName, service.id);
                //console.log(integration);
            }
        } else {
            this.serverless.cli.log(`Oncall service exists`);
            if (service.integrations.length > 0) {
                //console.log(pdService.integrations[0]);
                //console.log(pdService.integrations[0].config);
            } else {
                await this.createIntegration(pd, serviceName, service.id);
                //console.log(integration.body.integration.config);
            }
        }
    }

    logService(service: Service) {
        this.serverless.cli.consoleLog(`    Service ${service.name}: ${service.html_url}`);
        this.serverless.cli.consoleLog(`    Escalation policy ${service.escalation_policy.summary}: ${service.escalation_policy.html_url}`);
        service.teams.forEach(team => this.serverless.cli.consoleLog(`    Managed by ${team.summary}: ${team.html_url}`));
    }

    async info() {
        const config = this.config();
        const serviceName = `${this.serverless.service.service}-${this.provider.getStage()}`;
        const apiKey = config.apiKey;
        if (!apiKey) {
            throw new Error(API_KEY_MISSING);
        }
        const pd: PagerDutyClient = new PagerDuty(apiKey);
        let pdService = await this.findSevice(pd, serviceName);
        if (pdService === undefined) {
            // service does not yet exist
            return;
        }
        this.serverless.cli.log("Oncall");
        this.logService(pdService);
    }

};
